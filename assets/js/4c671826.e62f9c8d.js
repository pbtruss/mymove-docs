"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[3201],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var s=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},o=Object.keys(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),u=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=u(e.components);return s.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},c=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),c=u(n),m=i,k=c["".concat(l,".").concat(m)]||c[m]||p[m]||o;return n?s.createElement(k,a(a({ref:t},d),{},{components:n})):s.createElement(k,a({ref:t},d))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=c;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,a[1]=r;for(var u=2;u<o;u++)a[u]=n[u];return s.createElement.apply(null,a)}return s.createElement.apply(null,n)}c.displayName="MDXCreateElement"},74768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>u});var s=n(87462),i=(n(67294),n(3905));const o={sidebar_position:15},a="Session management",r={unversionedId:"backend/guides/session-management",id:"backend/guides/session-management",title:"Session management",description:"Background",source:"@site/docs/backend/guides/session-management.md",sourceDirName:"backend/guides",slug:"/backend/guides/session-management",permalink:"/mymove-docs/docs/backend/guides/session-management",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/backend/guides/session-management.md",tags:[],version:"current",sidebarPosition:15,frontMatter:{sidebar_position:15},sidebar:"backendSidebar",previous:{title:"Route Planner Guide",permalink:"/mymove-docs/docs/backend/guides/route-planner"},next:{title:"Roles and Permissions",permalink:"/mymove-docs/docs/backend/guides/roles-and-permissions"}},l={},u=[{value:"Background",id:"background",level:2},{value:"Local setup",id:"local-setup",level:2},{value:"Customization",id:"customization",level:2},{value:"Idle timeout",id:"idle-timeout",level:3},{value:"Session Lifetime",id:"session-lifetime",level:3},{value:"Session Cookie attributes",id:"session-cookie-attributes",level:3},{value:"Redis",id:"redis",level:2}],d={toc:u};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,s.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"session-management"},"Session management"),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"MilMove uses server-side session management because our ATO (Authority to Operate) requires that we be able to revoke individual sessions. This is not possible with JWTs (our previous session implementation) or cookies. We chose Redis because it can automatically delete expired sessions. With Postgres, we would need to run a routine\nperiodically to clean up stale sessions."),(0,i.kt)("p",null,"After researching various session management solutions, we chose\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/alexedwards/scs"},(0,i.kt)("inlineCode",{parentName:"a"},"scs"))," because it was the easiest to\nintegrate, and it supports various stores out of the box. It is the second most\npopular repo after ",(0,i.kt)("inlineCode",{parentName:"p"},"gorilla/sessions"),". We didn't pick ",(0,i.kt)("inlineCode",{parentName:"p"},"gorilla/sessions")," because\nit suffers from memory leak issues, and uses its own ",(0,i.kt)("inlineCode",{parentName:"p"},"context")," instead of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"request.Context()")," provided by Golang. The maintainers are aware of the issues\nand have opened a GitHub issue to propose ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/gorilla/sessions/issues/105"},"improvements for\nv2"),". However, it doesn't look\nlike any progress has been made over the past 2 years, while ",(0,i.kt)("inlineCode",{parentName:"p"},"scs")," has\nimplemented most of those improvements."),(0,i.kt)("h2",{id:"local-setup"},"Local setup"),(0,i.kt)("p",null,"Run ",(0,i.kt)("inlineCode",{parentName:"p"},"make deps")," to make sure your local setup is up to date and to pull the Redis image. That should be all you need to be able to sign in and out of the various apps."),(0,i.kt)("h2",{id:"customization"},"Customization"),(0,i.kt)("p",null,"There are various ENV vars you can set in your ",(0,i.kt)("inlineCode",{parentName:"p"},".envrc.local")," to customize your sessions."),(0,i.kt)("h3",{id:"idle-timeout"},"Idle timeout"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SESSION_IDLE_TIMEOUT_IN_MINUTES")," defines how long you can be idle while signed in before your session expires. The default is 15 minutes and is defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg/cli/session.go"),". To test a value less than 15 minutes or greater than 30 minutes, comment out the following lines in ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg/cli/session.go"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"if err := ValidateSessionTimeout(v, SessionIdleTimeoutInMinutesFlag); err != nil {\n    return err\n}\n")),(0,i.kt)("p",null,"To disable idle timeout, set it to ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),".\nExample usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"export SESSION_IDLE_TIMEOUT_IN_MINUTES=2\n")),(0,i.kt)("h3",{id:"session-lifetime"},"Session Lifetime"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SESSION_LIFETIME_IN_HOURS")," defines the absolute duration of the session. For example, once you sign in, even if you make requests continually, your session will expire after the lifetime has been reached. The default is 24 hours and is defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg/cli/session.go"),".\nExample usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"export SESSION_LIFETIME_IN_HOURS=12\n")),(0,i.kt)("h3",{id:"session-cookie-attributes"},"Session Cookie attributes"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"scs")," allows us to customize various attributes of the session cookie. We should rarely need to modify those, but if we need to, they are configured in ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupSessionManagers")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg/auth/session.go"),"."),(0,i.kt)("h2",{id:"redis"},"Redis"),(0,i.kt)("p",null,"You shouldn't need to change any of the Redis config, but if you're curious, it's defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"pkg/cli/redis.go"),"\nTo access the Redis console, run ",(0,i.kt)("inlineCode",{parentName:"p"},"redis-dev"),". You can then view all keys with ",(0,i.kt)("inlineCode",{parentName:"p"},"KEYS *"),". The session keys will have the prefix ",(0,i.kt)("inlineCode",{parentName:"p"},"scs:session"),"."))}p.isMDXComponent=!0}}]);